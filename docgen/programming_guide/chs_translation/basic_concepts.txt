基本概念
==============

在进行cocos2d应用开发之前，你需要在这个部分了解一些基本概念。
There are some basic concepts introduced in this library that you will
need to know when developing a cocos2d application:

.. contents::
    :local:

Scenes（场景）
------

场景 (用 `Scene` 对象实现)在整个应用工作流中
是一个相对独立的部分。
它也被叫做 "screens"（屏） 或者 "stages"（舞台）. 你的游戏可能有多个场景
但同一时间能处于激活状态的只有一个.

例如，你的一个游戏可能包含如下场景:
Intro（引入）, Menu（菜单）, Level 1（关卡1）, Cutscene 1（过场1）, Level 2（过场2）, Winning cutscene（过关过场）,
losing cutscene（失败过场）, High scores screen（高分画面）.

你可以多多少少将这些场景声明为独立的模块;
你有许多逻辑或者方法将这些场景关联起来
(引入结束或者被中断的时候将进入菜单界面,
第一关通过会将你带入过关过场，失败则将你带到失败过场, 等等诸如此类.).

.. figure:: scenes.png

cocos2d中的场景被描述为一个节点树(tree of CocosNodes)，树根为一个
“场景（`Scene`）”对象节点，场景的直接下层通常是“层（`Layers`）”,
层被用来组织相互独立的元素集合。

一个主菜单场景的例子::

	main_menu_scene : 主菜单场景，存放了所有元素的一个场景节点。
		animated_background : 可动背景，一个渲染菜单动画的Layer节点。
			static_background : 静态层，覆盖全屏的一张美图。
			far_trees : 放置远处的树的Layer节点。
				tree_1..tree_k : N棵树的精灵（Sprite） 
			birds : 放置鸟的层（Layer）节点。
				bird_1..bird_n : 代表鸟的精灵
			near_trees : 控制最近那棵树的层（Layer）
				tree_1..tree_m : 代表树的精灵（Sprite）
		main_menu : 菜单, cocos提供的一个菜单类的子类，控制所有的菜单行为。
					菜单相关 (键盘监听, 高亮, 选择功能...)
			item1 : MenuItem对象 , 'play'
			item2 : MenuItem , 'options'
			item3 : MenuItem , 'quit'

There is also a family of `Scene` subclasses called transitions (implemented with
the `TrasitionScene` object) which allow you to
make transitions between two scenes (fade out/in, slide from a side, etc).

Since scenes are subclass of `CocosNode`, they can be transformed manually or
by using actions.
See :doc:`actions` for more detail about actions.

Director
--------

The `Director` is the component which takes care about going back and forth
between scenes.

The `Director` is a shared (singleton) object. It knows which scene is currently
active, and it handles a stack of scenes to allow things like "scene calls"
(pausing a `Scene` and putting it on hold while other enters, and then returning
to the original). The push, replacement or end of the current scene is made by director.

The `Director` is also responsible of initializing the main window.

Layers
------

Layers helps you organize the scene in the back to front axis, by example

	- background : a fixed draw of landscape
	- far : decorative trees and birds
	- middle : platforms
	- near : player, enemies, coins
	- HUD : Heads Up Display to show game stats like life, energy

You can think layers as (usually) transparent sheets where the children are drawn, and the scene as the stack of sheets

.. image:: layers.png

In non MVC design style some code related to nodes interaction tends to float at the layer holding the entities, providing higher functional units.
By example, `Menu` is a Layer subclass that knows how to layout and animate items, read user input and do control flow.

Layers are the ones defining appearance and behavior, so most of your programming
time will be spent coding `Layer` subclasses that do what you need. 

The `Layer` is where you define event handlers. Events are propagated to layers
(from front to back) until some layer catches the event and accepts it.

Even if any serious app will require you to define some `Layer` subclasses, cocos2d
provides some useful specialized layers

	- `MultiplexLayer`, a group of layers where only one is seen at a time
	- `ScrollingManager`, `ScrollableLayer`; does the logic to limit scroll to viewable areas
	- `RectMapLayer`, `HexMapLayer`; displays a group of rectangular or hexagonal tiles
	- `Menu`, implements simple menus
	- `ColorLayer`, a solid color rectangle
	- `InterpreterLayer`, used by director to pop up an interactive console to peek and poke at the objects in our scene ( ctrl + I to toggle on-off)

To make loading of appropriate assets easier you may override the ``init``
method of your `Layer` subclass. This will be called when your Layer is
created.

Since layers are subclass of `CocosNode`, they can be transformed manually or 
by using actions.
See :doc:`actions` for more detail about actions.


Sprites
-------

A cocos2d' sprite is like any other computer sprite.
It is a 2D image that can be moved, rotated, scaled, animated, etc. 

Sprites (implemented using the `Sprite` class) can have other sprites
as children. When a parent is transformed, all its children are transformed as well.

Since sprites are subclass of `CocosNode`, they can be transformed manually
or by using actions.
See :doc:`actions` for more detail about actions.


Events
------

cocos2d uses `The pyglet Event Framework`_ to handle events.

The pyglet event framework in a pinch
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

 - you have **emitters** (instances of pyglet.event.EventDispatcher)

 - each emitter registers as much events as desired, each one identified by a
   string (the event name)

 - to act over events, you register **listeners** with the emitter.
   Essentially, you provide the emitter with a (<event name>, callable) and the
   emitter will call the callable when <event name> happens.
   Any number of listeners can register for a (emitter, <event name>) pair.
   A listener can register to any number of emitters.

 - example registration **emitter** events::

        class Bunker(pyglet.event.EventDispatcher):
            ...
            def building_update(self, dt):
                ...
            if self.elapsed_time>self.building_time:
                self.dispatch_event('on_building_complete', self)

        def take_damage(self, damage):
            self.dispatch_event('on_building_under_attack', self)
            self.life -= damage
            if self.life<0:
                self.dispatch_event('on_building_destroyed', self)

        # following lines register the events that Bunker instances can emit
        Bunker.register_event_type('on_building_complete')
        Bunker.register_event_type('on_building_under_attack')
        Bunker.register_event_type('on_building_destroyed')

   Note that an event can carry zero, one or more arguments; here we send the
   instance emitting the event.

 - example registration **listeners**::
     
        class Commander(object):
            def __init__(self, ...):
                self.buildings = []
                ...

            def invest_resources(self):
                ...
                bunker = Bunker(...)
                # register to receive all events from object bunker
                bunker.push_handlers(self)
                self.buildings.append(bunker)
                ...

            # handlers for the events

            def on_building_complete(self, building):
                ...

            def on_building_under_attack(self, building):
                ...

            def on_building_destroyed(self, building):
                ...
                
   Note that the handlers accepts the parameters that the event carries.
   The listener registration here works as:

       - we pass a class instance to push_handlers
       - pyglet will look at methods in this class instance whose name match
         <event name> for any <event name> which the emitter registered, and
         then register ( <event name>, obj.event_name ) for each match.

   With this style of listener registration you should be careful when
   registering for two emitters: if both emitters can generate 'on_cuack'
   events and you register::

        emitter1.push_handlers(obj)
        emitter2.push_handlers(obj)

   then obj.on_cuack will be called by both emitters.

   Another listener registration style is pushing explicit handlers::

        bunker.push_handlers(
            self.on_building_complete,
            self.on_building_under_attack,
            self.on_building_destroyed
            )

 - When you want a listener to stop receiving events from an emitter, you de-register the listener::

        emitter.remove_handlers(...) # params as in push_handlers

 - Event propagation : The event is propagated to all handlers from the top of the emitter stack until one returns EVENT_HANDLED.


Cocos and events
^^^^^^^^^^^^^^^^

Besides using events to get user input ('on_key_press', 'on_mouse_move',...) or window status change ( 'on_activate', ... )
, you can use events to decouple the model from the view in your app. The game Tetrico, to be found in samples/tetrico is an example of this usage.

Cocos in general will **not** automatically handle listeners registration/de-registration, except for one special case: the emitter is director.window and the listener is a layer or scene
Thus, for the general case, you must handle the push_handlers - remove_handlers thing by yourself.
When your listener lives in a CocosNode, a good scheme is pushing handlers in the on_enter method and remove handlers in the on_exit method. This way, you are sure your handlers will not be called when the node is not in the active scene.
Also, for custom events, it is a good practice to not use event names that director.window uses: that prevents unexpected double calls to the handler(s).

For the special case that emitter is director.window and the listeners are layers or scenes, cocos can handle the registration / de-registration:

 - When a scene becomes active it would walk the scene tree to allow layers autoregistering for director.window events
   It would not attempt to register itself as a listener except if the scene.enable_handlers is called.
   The walk begins in the scene, and passes only to layer class childs.

 - When prompted from the above walk, a layer whose class member is_event_handler has value True will register itself as a director.window listener
   The registration will be on the form::
          
        director.window.push_handler(layer)

   so any method whose name matchs a <event name> will be registered as a listener.

 - When the scene becomes inactive ( by director.pop by example ), the matching walk calling::

        director.window.remove_handlers(layer)      

   will be issued.

Events generated by cocos itself:

    - ( director, 'on_push' )
    - ( director, 'on_pop' )
    - ( director, 'on_resize' )
    - ( director, 'on_cocos_resize')

Cocos registers a default key listener that provides handy functionality, see :doc:`default_handlers`

.. _The pyglet Event Framework: http://www.pyglet.org/doc/programming_guide/the_pyglet_event_framework.html
