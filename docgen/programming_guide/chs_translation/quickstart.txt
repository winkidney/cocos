编写一个基本的cocos2d应用
=============================

开始使用一个新框架会变得十分困难，尤其是有太多的参考材料需要阅读的时候。这一章将会对cocos2d进行一个非常简洁介绍，包括如下内容：

.. contents::
    :local:

Hello, World
------------

我们会从必要的“Hello,World”开始介绍。这个程序将会打开一个包含文字的窗口，这个窗口等待你的关闭。你可以在 `/samples/hello_world.py` 文件中找到整个程序。

.. image:: hello_world.py.png


我们先导入cocos包::

    import cocos

子类化 `Layer`  类并在此声明程序逻辑::

    class HelloWorld(cocos.layer.Layer):

记得在构造器里调用 ``super`` 方法::

    def __init__(self):
        super( HelloWorld, self ).__init__()

为了显示文字，你必须创建一个 `Label` 实例.  关键字参数分别设置了标签对象的字体，
显示位置，对齐方式::

    label = cocos.text.Label('Hello, world',
                              font_name='Times New Roman',
                              font_size=32,
                              anchor_x='center', anchor_y='center')

文本标签将显示在屏幕中间::

    label.position = 320,240

因为 `Label` 是 `CocosNode` 的子类，所以它可以作为孩子（child）被添加。
所有的 `CocosNode` 类型的对象都知道如何渲染自己，执行动作（actions）和产生变换。
使用  `CocosNode.add` 方法来将它添加为一个 `Layer` 对象的孩子（注：Layer也是CocosNode的子类）::

        self.add( label )

完成  ``HelloWorld``  类的声明之后，我们接下来需要初始化并创建一个窗口对象。
为了达到这个目的，我们初始化一个导演对象 `Director`::

    cocos.director.director.init()

然后我们创建一个 ``HelloWorld`` 实例::

    hello_layer = HelloWorld ()

接下来我们再创建一个场景对象 `Scene` 将  ``HelloWorld`` 实例作为孩子包含其中::

    main_scene = cocos.scene.Scene (hello_layer)

最后，我们运行场景对象::

    cocos.director.director.run (main_scene)

上面三行也可以写成一行::

    #cocos.director.director.run( cocos.scene.Scene( HelloWorld() ) )


Hello Actions
-------------

.. figure:: hello_world_actions.py.png

这个例子和第一个例子非常相似，不同的地方在于这个例子向你展示actions（动作）的世界。一个 “动作” 就像一个指令。你可以让
 **任何**  `CocosNode` 对象执行一个动作（action）
 
完整的程序可以在 `samples/hello_world_actions.py` 文件里找到.


就像我们之前的例子一样，我们先导入cocos包::

        import cocos

如果你打算使用多个action，你可以这样从名称空间里导入所有可用action::

    from cocos.actions import *

我们子类化 `ColorLayer` 来使用有背景色的层, 
然后我们调用super()方法来设定背景为蓝色::

    class HelloWorld(cocos.layer.ColorLayer):
        def __init__(self):
            # blueish color
            super( HelloWorld, self ).__init__( 64,64,224,255)

前一个例子中，我们创建并添加了一个标签（label）::

    label = cocos.text.Label('Hello, World!',
        font_name='Times New Roman',
        font_size=32,
        anchor_x='center', anchor_y='center')

    # 让标签显示在屏幕中间
    label.position = 320,240
    self.add( label )

在这个实例里我们也创建一个精灵并将其添加为一个孩子。
在cocos2d当中精灵是 `Sprite` 对象::

    sprite = cocos.sprite.Sprite('grossini.png')

我们将精灵放置在屏幕中间。默认位置是 (0,0)::

    sprite.position = 320,240

我们将缩放属性设置为3。这也就意味着我妈的精灵将变为三倍大小。
默认的缩放属性值是1::

    sprite.scale = 3

我们将精灵添加为父层级的孩子，通过设置z数值，我们将精灵放在了标签的上面，
因为默认的z数值是0::

    self.add( sprite, z=1 )

我们创建了一个 `ScaleBy` 动作，它将会在两秒时间内将精灵缩放三次::

    scale = ScaleBy(3, duration=2)

我们告诉label执行如下动作:
 1. 两秒的时间内缩放三次
 2. 接下来在两秒内缩放回去
 3. 最后我们无限循环这两个动作

注意 '+' 操作符是 `Sequence` （序列）动作::

    label.do( Repeat( scale + Reverse( scale) ) )

    sprite.do( Repeat( Reverse(scale) + scale ) )

然后我们让精灵执行相同的动作，但是从 `反向缩放` 开始::
接着我们初始化Director，就像我们前一个例子里做的::

    cocos.director.director.init()
    hello_layer = HelloWorld ()

然后，我们让 `Layer` （层）(如你所见, 所有的 `CocosNode` 对象都可以执行actions) 
在十秒内执行 360度的`RotateBy`  动作::

    hello_layer.do( RotateBy(360, duration=10) )

最后我们开始执行::

    # 一个包含hello_layer的场景
    main_scene = cocos.scene.Scene (hello_layer)

    # 现在，运行应用以载入主场景
    cocos.director.director.run (main_scene)


响应事件
---------------

之前所有的例子都是没有交互的。他们都显示内容，不响应用户输入 (除了你按 **ESC** 或者直接关闭窗口导致退出之外).
Cocos通过监听 director.window events 获取事件, 而且 cocos.layer 能方便的自动监听 director.window events: 你只需要在你的子类里将 is_event_handler 成员变量设置为 True ，剩下的工作cocos会帮你完成.

这个部分我们会一步一步构建 `samples/handling_events.py` 中包含的程序; 这个简单的应用将显示你按了哪些按键，鼠标如何移动，何时点击。在继续读下去之前，建议你先运行一下这个应用，了解下我们要构建的是一个什么样的东西。

.. figure:: event_demo.py.png

这个DEMO有两个层; 一个用来显示当前按键 (没有按键，按下一个, 或者同时按下几个按键), 另一个层显示鼠标坐标，点击并跟随鼠标移动.

我们先声明 KeyDisplay 层。跟之前一样，我们把一些初始化代码放在  ``__init__`` 方法里::

        class KeyDisplay(cocos.layer.Layer):

            # 如果你想要你的层对象监听 director.window events
            # 你必须设置这个变量为 'True'
            is_event_handler = True

            def __init__(self):

                super( KeyDisplay, self ).__init__()

                self.text = cocos.text.Label("", x=100, y=280 )

                # 跟踪哪一个按键被按下了
                self.keys_pressed = set()
                self.update_text()
                self.add(self.text)

            def update_text(self):
                key_names = [pyglet.window.key.symbol_string (k) for k in self.keys_pressed]
                text = 'Keys: '+','.join (key_names)
                # Update self.text
                self.text.element.text = text

这个类声明了一个按下的键的集合，这个集合记录了某个时刻按下的所有按键。尽管如此，这些代码依然什么都没做。我们需要让层在按键释放的时候自动更新这个集合。
换句话说，我们要给这个层增加事件响应。增加事件响应的具体方法是为类增加一个 on_<event name> 的方法。
现在我们感兴趣的方法是``on_key_press`` 和 ``on_key_release``::

        def on_key_press (self, key, modifiers):
            """方法会在按键按下的时候释放
            'key' 是用来判断哪个键被按下的变量。
            'modifiers' 是一个按位变量，标识了按键的同时哪个
            控制按键被按下了(ctrl, shift, capslock,等等)
            """

            self.keys_pressed.add (key)
            self.update_text()

        def on_key_release (self, key, modifiers):
            """这个方法在按键释放的时候被调用。

            'key' 是用来判断哪个键被按下的变量。
            'modifiers' 是一个按位变量，标识了按键的同时哪个
            控制按键被按下了(ctrl, shift, capslock, etc.)

            这些变量都来自于 pyglet.window.key
            """

            self.keys_pressed.remove (key)
            self.update_text()

        def update_text(self):
            key_names = [pyglet.window.key.symbol_string (k) for k in self.keys_pressed]
            text = 'Keys: '+','.join (key_names)
            # 更新 self.text
            self.text.element.text = text


写好这些，这个层已经可以正常工作了。现在按下然后释放按键或者组合键，你就可以看见屏幕上更新你在某个时刻的所有按键了。

响应鼠标输入也是类似的。现在我们感兴趣的事件有三个：on_mouse_press, on_mouse_motion and on_mouse_drag.有了这些数据，我们就可以声明的我我们的层了::

        class MouseDisplay(cocos.layer.Layer):

            is_event_handler = True     #: 启用 director.window events

            def __init__(self):
                super( MouseDisplay, self ).__init__()

                self.posx = 100
                self.posy = 240
                self.text = cocos.text.Label('No mouse events yet', font_size=18, x=self.posx, y=self.posy )
                self.add( self.text )

            def update_text (self, x, y):
                text = 'Mouse @ %d,%d' % (x, y)
                self.text.element.text = text
                self.text.element.x = self.posx
                self.text.element.y = self.posy

接下来添加鼠标移动改变文字的事件响应，当按下鼠标的时候改变文字坐标。::

    def on_mouse_motion (self, x, y, dx, dy):
        """鼠标移动（没有按下鼠标）的时候调用这个方法
        
        (x, y) 是鼠标的物理坐标
        (dx, dy) 是上一次调用和这一次调用的坐标之差
        """
        self.update_text (x, y)

    def on_mouse_drag (self, x, y, dx, dy, buttons, modifiers):
        """鼠标拖动（按下了一个或多个鼠标按钮）的时候调用这个方法
        
        (x, y) 是鼠标的物理坐标
        (dx, dy) 是上一次调用和这一次调用的坐标之差
        'buttons' 是一个 pyglet.window.mouse 值为 LEFT, MIDDLE, RIGHT 的位变量
        'modifiers' 是一个 pyglet.window.key  控制键位变量(比如 'SHIFT', 'OPTION', 'ALT'等等)
        """
        self.update_text (x, y)

    def on_mouse_press (self, x, y, buttons, modifiers):
        """函数在鼠标有按钮按下的时候调用

        (x, y) 是鼠标的物理坐标
        'buttons' 是 pyglet.window.mouse 中的一个位变量,包含 LEFT, MIDDLE, RIGHT三个值.
        'modifiers' 是一个 pyglet.window.key  控制键位变量(比如 'SHIFT', 'OPTION', 'ALT'等等)
        """
        self.posx, self.posy = director.get_virtual_coordinates (x, y)
        self.update_text (x,y)

这里和前面唯一有少许不同的地方是对 `director.get_virtual_coordinates` (x, y)的调用. 就像我们前面说的一样,cocos有两个坐标系统,一个物理坐标系统,一个虚拟坐标系统. 鼠标事件响应从pyglet接收物理坐标信息. 如果你想要映射到虚拟坐标, 你需要使用 director.get_virtual_coordinates 方法来做正确的映射, . 如果你在on_mouse_press handler使用 ``self.posx``, ``self.posy = x,y`` 作为替代, 你会看到和前面的方法一致的表现, 但如果你改变窗口大小, 点击就会将文字移动到错误的坐标.

补充以下,还有其他的有趣的鼠标事件:
	on_mouse_release : 鼠标按键被释放的时候触发.
	on_mouse_scroll : 鼠标滚轮移动时被触发.
	on_mouse_leave : 光标移出窗口范围时触发.
	on_mouse_enter : 光标进入窗口范围被触发.

Demo没有更多代码, 你只需要创建一个包含这两个layer的scene就可以运行了::

        director.init(resizable=True)
        # 用一个scene运行我们的事件监视器:
        director.run( cocos.scene.Scene( KeyDisplay(), MouseDisplay() ) )

现在你可以玩一下这个demo或者改改它,比如下面这些东西:

 * 改变 on_mouse_press 响应函数 并移除虚拟坐标映射; 注意现在窗口改变大小后文字行为的不同之处.
 * 注意,显示在屏幕上的鼠标坐标是物理坐标, 因此,当窗口大小改变的时候他们的取值范围也会发生变化; 修改demo来显示出虚拟坐标.
 * 修改代码,让显示鼠标坐标的标签能够被鼠标拖拽移动.
 * 修改代码,让显示键盘按键的文字同时能够显示按下的功能键盘.

接下来我该从哪开始?
--------------------------------

这一章给出的例子应该给你提供了足够你写一个简单的基于点击的游戏应用
的信息.


这个编程指南的剩余部分将会非常详尽的描述技术细节
并解释涉及的cocos的特性.  开始下一步之前, 推荐
你先扫一遍每个章节的标题,不用每个章节都从头到尾地细读.

为了在2D游戏中获得更好的性能表现
你也许需要在你的应用中直接调用OPENGL库.  OPENGL标准库手册见  `OpenGL编程指南`_ 和
`OpenGL着色器语言`_.

因为cocos2d使用pyglet,所以你还可以参考 `pyglet编程指南`_
和 `pyglet API参考`_

在 cocos2d源代码和文档文件夹里的 ``samples/`` 文件夹中有很多cocos2d的程序范例
.  关注
http://www.cocos2d.org/ 以第一时间获得更多范例和快速指南.





.. _OpenGL编程指南: http://opengl.org/documentation/books/#the_opengl_programming_guide_the_official_guide_to_learning_opengl_version
.. _OpenGL着色器语言: http://opengl.org/documentation/books/#the_opengl_shading_language_2nd_edition
.. _pyglet编程指南: http://pyglet.org/doc/programming_guide/
.. _pyglet API参考: http://pyglet.org/doc/api/
.. _The pyglet Event Framework: http://www.pyglet.org/doc/programming_guide/the_pyglet_event_framework.html
