编写一个基本的cocos2d应用
=============================

开始使用一个新框架会变得十分困难，尤其是有太多的参考材料需要阅读的时候。这一章将会对cocos2d进行一个非常简洁介绍，包括如下内容：

.. contents::
    :local:

Hello, World
------------

我们会从必要的“Hello,World”开始介绍。这个程序将会打开一个包含文字的窗口，这个窗口等待你的关闭。你可以在 `/samples/hello_world.py` 文件中找到整个程序。

.. image:: hello_world.py.png


我们先导入cocos包::

    import cocos

子类化 `Layer`  类并在此声明程序逻辑::

    class HelloWorld(cocos.layer.Layer):

记得在构造器里调用 ``super`` 方法::

    def __init__(self):
        super( HelloWorld, self ).__init__()

为了显示文字，你必须创建一个 `Label` 实例.  关键字参数分别设置了标签对象的字体，
显示位置，对齐方式::

    label = cocos.text.Label('Hello, world',
                              font_name='Times New Roman',
                              font_size=32,
                              anchor_x='center', anchor_y='center')

文本标签将显示在屏幕中间::

    label.position = 320,240

因为 `Label` 是 `CocosNode` 的子类，所以它可以作为孩子（child）被添加。
所有的 `CocosNode` 类型的对象都知道如何渲染自己，执行动作（actions）和产生变换。
使用  `CocosNode.add` 方法来将它添加为一个 `Layer` 对象的孩子（注：Layer也是CocosNode的子类）::

        self.add( label )

完成  ``HelloWorld``  类的声明之后，我们接下来需要初始化并创建一个窗口对象。
为了达到这个目的，我们初始化一个导演对象 `Director`::

    cocos.director.director.init()

然后我们创建一个 ``HelloWorld`` 实例::

    hello_layer = HelloWorld ()

接下来我们再创建一个场景对象 `Scene` 将  ``HelloWorld`` 实例作为孩子包含其中::

    main_scene = cocos.scene.Scene (hello_layer)

最后，我们运行场景对象::

    cocos.director.director.run (main_scene)

上面三行也可以写成一行::

    #cocos.director.director.run( cocos.scene.Scene( HelloWorld() ) )


Hello Actions
-------------

.. figure:: hello_world_actions.py.png

这个例子和第一个例子非常相似，不同的地方在于这个例子向你展示actions（动作）的世界。一个 “动作” 就像一个指令。你可以让
 **任何**  `CocosNode` 对象执行一个动作（action）
 
完整的程序可以在 `samples/hello_world_actions.py` 文件里找到.


就像我们之前的例子一样，我们先导入cocos包::

        import cocos

如果你打算使用多个action，你可以这样从名称空间里导入所有可用action::

    from cocos.actions import *

我们子类化 `ColorLayer` 来使用有背景色的层, 
然后我们调用super()方法来设定背景为蓝色::

    class HelloWorld(cocos.layer.ColorLayer):
        def __init__(self):
            # blueish color
            super( HelloWorld, self ).__init__( 64,64,224,255)

前一个例子中，我们创建并添加了一个标签（label）::

    label = cocos.text.Label('Hello, World!',
        font_name='Times New Roman',
        font_size=32,
        anchor_x='center', anchor_y='center')

    # 让标签显示在屏幕中间
    label.position = 320,240
    self.add( label )

在这个实例里我们也创建一个精灵并将其添加为一个孩子。
在cocos2d当中精灵是 `Sprite` 对象::

    sprite = cocos.sprite.Sprite('grossini.png')

我们将精灵放置在屏幕中间。默认位置是 (0,0)::

    sprite.position = 320,240

我们将缩放属性设置为3。这也就意味着我妈的精灵将变为三倍大小。
默认的缩放属性值是1::

    sprite.scale = 3

我们将精灵添加为父层级的孩子，通过设置z数值，我们将精灵放在了标签的上面，
因为默认的z数值是0::

    self.add( sprite, z=1 )

我们创建了一个 `ScaleBy` 动作，它将会在两秒时间内将精灵缩放三次::

    scale = ScaleBy(3, duration=2)

我们告诉label执行如下动作:
 1. 两秒的时间内缩放三次
 2. 接下来在两秒内缩放回去
 3. 最后我们无限循环这两个动作

注意 '+' 操作符是 `Sequence` （序列）动作::

    label.do( Repeat( scale + Reverse( scale) ) )

    sprite.do( Repeat( Reverse(scale) + scale ) )

然后我们让精灵执行相同的动作，但是从 `反向缩放` 开始::
接着我们初始化Director，就像我们前一个例子里做的::

    cocos.director.director.init()
    hello_layer = HelloWorld ()

然后，我们让 `Layer` （层）(如你所见, 所有的 `CocosNode` 对象都可以执行actions) 
在十秒内执行 360度的`RotateBy`  动作::

    hello_layer.do( RotateBy(360, duration=10) )

最后我们开始执行::

    # 一个包含hello_layer的场景
    main_scene = cocos.scene.Scene (hello_layer)

    # 现在，运行应用以载入主场景
    cocos.director.director.run (main_scene)


Handling Events
---------------

All our previous examples are non-interactive. They display something, but do not respond to user input (except for quitting when you press **ESC** or close the window).
Cocos obtains inputs by listening to director.window events, and conveniently cocos.layer can automatically listen to director.window events: in your layer subclass set the is_event_handler class member to True and cocos will take care.

In this section we will build step by step the demo provided in `samples/handling_events.py`; this is a very simple cocos app which shows which keys are pressed, and reacts to mouse motion and clicks. Run the app before reading on te get a clearer idea of what we are trying to build.

.. figure:: event_demo.py.png

This demo has a scene with two layers; one shows which keys are currently pressed (none, one, or maybe several at the same time), the other one shows text with the mouse position, and clicking moves the text.

We start defining the KeyDisplay layer class. As always, we put some initialization on ``__init__`` and the code for displaying it in step::

        class KeyDisplay(cocos.layer.Layer):

            # If you want that your layer receives director.window events
            # you must set this variable to 'True'
            is_event_handler = True

            def __init__(self):

                super( KeyDisplay, self ).__init__()

                self.text = cocos.text.Label("", x=100, y=280 )

                # To keep track of which keys are pressed:
                self.keys_pressed = set()
                self.update_text()
                self.add(self.text)

            def update_text(self):
                key_names = [pyglet.window.key.symbol_string (k) for k in self.keys_pressed]
                text = 'Keys: '+','.join (key_names)
                # Update self.text
                self.text.element.text = text

This class defines a key_pressed set, which should be the set of keys pressed at any time. However, this code as it is still does nothing. We need to tell this layer to update this set when a key is pressed or released. In other words, we need to add event handlers to the layer. Adding event handlers to a layer is just a matter of adding methods to it called on_<event name>. The two events that interest us now are ``on_key_press`` and ``on_key_release``::

        def on_key_press (self, key, modifiers):
            """This function is called when a key is pressed.
            'key' is a constant indicating which key was pressed.
            'modifiers' is a bitwise or of several constants indicating which
                modifiers are active at the time of the press (ctrl, shift, capslock, etc.)
            """

            self.keys_pressed.add (key)
            self.update_text()

        def on_key_release (self, key, modifiers):
            """This function is called when a key is released.

            'key' is a constant indicating which key was pressed.
            'modifiers' is a bitwise or of several constants indicating which
                modifiers are active at the time of the press (ctrl, shift, capslock, etc.)

            Constants are the ones from pyglet.window.key
            """

            self.keys_pressed.remove (key)
            self.update_text()

        def update_text(self):
            key_names = [pyglet.window.key.symbol_string (k) for k in self.keys_pressed]
            text = 'Keys: '+','.join (key_names)
            # Update self.text
            self.text.element.text = text

With that code, the layer is now fully working. You can press and release keys or key combinations, and you will se how the display is updated telling you which keys are pressed at any time.

Handling mouse input is similar. You have three events of interest: on_mouse_press, on_mouse_motion and on_mouse_drag. With that, we can define our layer::

        class MouseDisplay(cocos.layer.Layer):

            is_event_handler = True     #: enable director.window events

            def __init__(self):
                super( MouseDisplay, self ).__init__()

                self.posx = 100
                self.posy = 240
                self.text = cocos.text.Label('No mouse events yet', font_size=18, x=self.posx, y=self.posy )
                self.add( self.text )

            def update_text (self, x, y):
                text = 'Mouse @ %d,%d' % (x, y)
                self.text.element.text = text
                self.text.element.x = self.posx
                self.text.element.y = self.posy

And then add event handlers to update the text when the mouse is moved, and change the text position when any button is clicked::

    def on_mouse_motion (self, x, y, dx, dy):
        """Called when the mouse moves over the app window with no button pressed
        
        (x, y) are the physical coordinates of the mouse
        (dx, dy) is the distance vector covered by the mouse pointer since the
          last call.
        """
        self.update_text (x, y)

    def on_mouse_drag (self, x, y, dx, dy, buttons, modifiers):
        """Called when the mouse moves over the app window with some button(s) pressed
        
        (x, y) are the physical coordinates of the mouse
        (dx, dy) is the distance vector covered by the mouse pointer since the
          last call.
        'buttons' is a bitwise or of pyglet.window.mouse constants LEFT, MIDDLE, RIGHT
        'modifiers' is a bitwise or of pyglet.window.key modifier constants
           (values like 'SHIFT', 'OPTION', 'ALT')
        """
        self.update_text (x, y)

    def on_mouse_press (self, x, y, buttons, modifiers):
        """This function is called when any mouse button is pressed

        (x, y) are the physical coordinates of the mouse
        'buttons' is a bitwise or of pyglet.window.mouse constants LEFT, MIDDLE, RIGHT
        'modifiers' is a bitwise or of pyglet.window.key modifier constants
           (values like 'SHIFT', 'OPTION', 'ALT')
        """
        self.posx, self.posy = director.get_virtual_coordinates (x, y)
        self.update_text (x,y)

The only thing a bit unusual here is the call to `director.get_virtual_coordinates` (x, y). As explained in the example before, cocos has two coordinates systems, a physical one and a virtual one. The mouse event handlers receive their arguments from pyglet in physical coordinates. If you want to map that to virtual coordinates, you need to use the director.get_virtual_coordinates method, which does the correct mapping. If you put instead ``self.posx``, ``self.posy = x,y`` in the on_mouse_press handler above, you will see that the app seems to work, but if you resize the window, the clicks will move the text to the wrong place.

For completneddes, they are other mouse events that can be of interest:
	on_mouse_release : called when a button is released
	on_mouse_scroll : called when the mouse wheel moved
	on_mouse_leave : called when the mouse cursor goes out of the window
	on_mouse_enter : called when the mouse cursor enters the window

The demo does not have much more code, just creating a scene with these two layers and running it::

        director.init(resizable=True)
        # Run a scene with our event displayers:
        director.run( cocos.scene.Scene( KeyDisplay(), MouseDisplay() ) )

You can now play to the demo and change it. Some things you can try are:

 * Change the on_mouse_press handler and remove the mapping to virtual coordinates; note how it behaves strangely after resizing the window
 * Note that the mouse coordinates on screen are physical coordinates, so their range changes when resizing the window; modify the demo to show virtual coordinates.
 * Change the code to be able to move the mouse coordinates label when you drag the mouse
 * Change the code so the keyboard display also shows the modifiers set at each time

Where to next?
--------------

The examples presented in this chapter should have given you enough
information to get started writing simple arcade and point-and-click-based
games.

The remainder of this programming guide goes into quite technical detail
regarding some of cocos's features.  While getting started, it's recommended
that you skim the beginning of each chapter but not attempt to read through
the entire guide from start to finish.

To achieve optimal performance in your 2D
applications you'll need to work with OpenGL directly.  The canonical
references for OpenGL are `The OpenGL Programming Guide`_ and
`The OpenGL Shading Language`_.

Since cocos2d uses pyglet you shall also check `pyglet Programming Guide`_
and `pyglet API Reference`_

There are numerous examples of cocos2d applications in the ``samples/``
directory of the documentation and source distributions.  Keep checking
http://www.cocos2d.org/ for more examples and tutorials as they are written.





.. _The OpenGL Programming Guide: http://opengl.org/documentation/books/#the_opengl_programming_guide_the_official_guide_to_learning_opengl_version
.. _The OpenGL Shading Language: http://opengl.org/documentation/books/#the_opengl_shading_language_2nd_edition
.. _pyglet Programming Guide: http://pyglet.org/doc/programming_guide/
.. _pyglet API Reference: http://pyglet.org/doc/api/
.. _The pyglet Event Framework: http://www.pyglet.org/doc/programming_guide/the_pyglet_event_framework.html
