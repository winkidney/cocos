编写一个基本的cocos2d应用
=============================

开始使用一个新框架会变得十分困难，尤其是有太多的参考材料需要阅读的时候。这一章将会对cocos2d进行一个非常简洁介绍，包括如下内容：

.. contents::
    :local:

Hello, World
------------

我们会从必要的“Hello,World”开始介绍。这个程序将会打开一个包含文字的窗口，这个窗口等待你的关闭。你可以在 `/samples/hello_world.py` 文件中找到整个程序。

.. image:: hello_world.py.png


我们先导入cocos包::

    import cocos

子类化 `Layer`  类并在此声明程序逻辑::

    class HelloWorld(cocos.layer.Layer):

记得在构造器里调用 ``super`` 方法::

    def __init__(self):
        super( HelloWorld, self ).__init__()

为了显示文字，你必须创建一个 `Label` 实例.  关键字参数分别设置了标签对象的字体，
显示位置，对齐方式::

    label = cocos.text.Label('Hello, world',
                              font_name='Times New Roman',
                              font_size=32,
                              anchor_x='center', anchor_y='center')

文本标签将显示在屏幕中间::

    label.position = 320,240

因为 `Label` 是 `CocosNode` 的子类，所以它可以作为孩子（child）被添加。
所有的 `CocosNode` 类型的对象都知道如何渲染自己，执行动作（actions）和产生变换。
使用  `CocosNode.add` 方法来将它添加为一个 `Layer` 对象的孩子（注：Layer也是CocosNode的子类）::

        self.add( label )

完成  ``HelloWorld``  类的声明之后，我们接下来需要初始化并创建一个窗口对象。
为了达到这个目的，我们初始化一个导演对象 `Director`::

    cocos.director.director.init()

然后我们创建一个 ``HelloWorld`` 实例::

    hello_layer = HelloWorld ()

接下来我们再创建一个场景对象 `Scene` 将  ``HelloWorld`` 实例作为孩子包含其中::

    main_scene = cocos.scene.Scene (hello_layer)

最后，我们运行场景对象::

    cocos.director.director.run (main_scene)

上面三行也可以写成一行::

    #cocos.director.director.run( cocos.scene.Scene( HelloWorld() ) )


Hello Actions
-------------

.. figure:: hello_world_actions.py.png

这个例子和第一个例子非常相似，不同的地方在于这个例子向你展示actions（动作）的世界。一个 “动作” 就像一个指令。你可以让
 **任何**  `CocosNode` 对象执行一个动作（action）
 
完整的程序可以在 `samples/hello_world_actions.py` 文件里找到.


就像我们之前的例子一样，我们先导入cocos包::

        import cocos

如果你打算使用多个action，你可以这样从名称空间里导入所有可用action::

    from cocos.actions import *

我们子类化 `ColorLayer` 来使用有背景色的层, 
然后我们调用super()方法来设定背景为蓝色::

    class HelloWorld(cocos.layer.ColorLayer):
        def __init__(self):
            # blueish color
            super( HelloWorld, self ).__init__( 64,64,224,255)

前一个例子中，我们创建并添加了一个标签（label）::

    label = cocos.text.Label('Hello, World!',
        font_name='Times New Roman',
        font_size=32,
        anchor_x='center', anchor_y='center')

    # 让标签显示在屏幕中间
    label.position = 320,240
    self.add( label )

在这个实例里我们也创建一个精灵并将其添加为一个孩子。
在cocos2d当中精灵是 `Sprite` 对象::

    sprite = cocos.sprite.Sprite('grossini.png')

我们将精灵放置在屏幕中间。默认位置是 (0,0)::

    sprite.position = 320,240

我们将缩放属性设置为3。这也就意味着我妈的精灵将变为三倍大小。
默认的缩放属性值是1::

    sprite.scale = 3

我们将精灵添加为父层级的孩子，通过设置z数值，我们将精灵放在了标签的上面，
因为默认的z数值是0::

    self.add( sprite, z=1 )

我们创建了一个 `ScaleBy` 动作，它将会在两秒时间内将精灵缩放三次::

    scale = ScaleBy(3, duration=2)

我们告诉label执行如下动作:
 1. 两秒的时间内缩放三次
 2. 接下来在两秒内缩放回去
 3. 最后我们无限循环这两个动作

注意 '+' 操作符是 `Sequence` （序列）动作::

    label.do( Repeat( scale + Reverse( scale) ) )

    sprite.do( Repeat( Reverse(scale) + scale ) )

然后我们让精灵执行相同的动作，但是从 `反向缩放` 开始::
接着我们初始化Director，就像我们前一个例子里做的::

    cocos.director.director.init()
    hello_layer = HelloWorld ()

然后，我们让 `Layer` （层）(如你所见, 所有的 `CocosNode` 对象都可以执行actions) 
在十秒内执行 360度的`RotateBy`  动作::

    hello_layer.do( RotateBy(360, duration=10) )

最后我们开始执行::

    # 一个包含hello_layer的场景
    main_scene = cocos.scene.Scene (hello_layer)

    # 现在，运行应用以载入主场景
    cocos.director.director.run (main_scene)


响应事件
---------------

之前所有的例子都是没有交互的。他们都显示内容，不响应用户输入 (除了你按 **ESC** 或者直接关闭窗口导致退出之外).
Cocos通过监听 director.window events 获取事件, 而且 cocos.layer 能方便的自动监听 director.window events: 你只需要在你的子类里将 is_event_handler 成员变量设置为 True ，剩下的工作cocos会帮你完成.

这个部分我们会一步一步构建 `samples/handling_events.py` 中包含的程序; 这个简单的应用将显示你按了哪些按键，鼠标如何移动，何时点击。在继续读下去之前，建议你先运行一下这个应用，了解下我们要构建的是一个什么样的东西。

.. figure:: event_demo.py.png

这个DEMO有两个层; 一个用来显示当前按键 (没有按键，按下一个, 或者同时按下几个按键), 另一个层显示鼠标坐标，点击并跟随鼠标移动.

我们先声明 KeyDisplay 层。跟之前一样，我们把一些初始化代码放在  ``__init__`` 方法里::

        class KeyDisplay(cocos.layer.Layer):

            # 如果你想要你的层对象监听 director.window events
            # 你必须设置这个变量为 'True'
            is_event_handler = True

            def __init__(self):

                super( KeyDisplay, self ).__init__()

                self.text = cocos.text.Label("", x=100, y=280 )

                # 跟踪哪一个按键被按下了
                self.keys_pressed = set()
                self.update_text()
                self.add(self.text)

            def update_text(self):
                key_names = [pyglet.window.key.symbol_string (k) for k in self.keys_pressed]
                text = 'Keys: '+','.join (key_names)
                # Update self.text
                self.text.element.text = text

这个类声明了一个按下的键的集合，这个集合记录了某个时刻按下的所有按键。尽管如此，这些代码依然什么都没做。我们需要让层在按键释放的时候自动更新这个集合。
换句话说，我们要给这个层增加事件响应。增加事件响应的具体方法是为类增加一个 on_<event name> 的方法。
现在我们感兴趣的方法是``on_key_press`` 和 ``on_key_release``::

        def on_key_press (self, key, modifiers):
            """方法会在按键按下的时候释放
            'key' 是用来判断哪个键被按下的变量。
            'modifiers' 是一个按位变量，标识了按键的同时哪个
            控制按键被按下了(ctrl, shift, capslock,等等)
            """

            self.keys_pressed.add (key)
            self.update_text()

        def on_key_release (self, key, modifiers):
            """这个方法在按键释放的时候被调用。

            'key' 是用来判断哪个键被按下的变量。
            'modifiers' 是一个按位变量，标识了按键的同时哪个
            控制按键被按下了(ctrl, shift, capslock, etc.)

            这些变量都来自于 pyglet.window.key
            """

            self.keys_pressed.remove (key)
            self.update_text()

        def update_text(self):
            key_names = [pyglet.window.key.symbol_string (k) for k in self.keys_pressed]
            text = 'Keys: '+','.join (key_names)
            # 更新 self.text
            self.text.element.text = text


写好这些，这个层已经可以正常工作了。现在按下然后释放按键或者组合键，你就可以看见屏幕上更新你在某个时刻的所有按键了。

响应鼠标输入也是类似的。现在我们感兴趣的事件有三个：on_mouse_press, on_mouse_motion and on_mouse_drag.有了这些数据，我们就可以声明的我我们的层了::

        class MouseDisplay(cocos.layer.Layer):

            is_event_handler = True     #: 启用 director.window events

            def __init__(self):
                super( MouseDisplay, self ).__init__()

                self.posx = 100
                self.posy = 240
                self.text = cocos.text.Label('No mouse events yet', font_size=18, x=self.posx, y=self.posy )
                self.add( self.text )

            def update_text (self, x, y):
                text = 'Mouse @ %d,%d' % (x, y)
                self.text.element.text = text
                self.text.element.x = self.posx
                self.text.element.y = self.posy

接下来添加鼠标移动改变文字的事件响应，当按下鼠标的时候改变文字坐标。::

    def on_mouse_motion (self, x, y, dx, dy):
        """鼠标移动（没有按下鼠标）的时候调用这个方法
        
        (x, y) 是鼠标的物理坐标
        (dx, dy) 是上一次调用和这一次调用的坐标之差
        """
        self.update_text (x, y)

    def on_mouse_drag (self, x, y, dx, dy, buttons, modifiers):
        """鼠标拖动（按下了一个或多个鼠标按钮）的时候调用这个方法
        
        (x, y) 是鼠标的物理坐标
        (dx, dy) 是上一次调用和这一次调用的坐标之差
        'buttons' 是一个 pyglet.window.mouse 值为 LEFT, MIDDLE, RIGHT 的位变量
        'modifiers' 是一个 pyglet.window.key  控制键位变量(比如 'SHIFT', 'OPTION', 'ALT'等等)
        """
        self.update_text (x, y)

    def on_mouse_press (self, x, y, buttons, modifiers):
        """函数在鼠标有按钮按下的时候调用

        (x, y) 是鼠标的物理坐标
        'buttons' is a bitwise or of pyglet.window.mouse constants LEFT, MIDDLE, RIGHT
        'modifiers' is a bitwise or of pyglet.window.key modifier constants
           (values like 'SHIFT', 'OPTION', 'ALT')
        """
        self.posx, self.posy = director.get_virtual_coordinates (x, y)
        self.update_text (x,y)

The only thing a bit unusual here is the call to `director.get_virtual_coordinates` (x, y). As explained in the example before, cocos has two coordinates systems, a physical one and a virtual one. The mouse event handlers receive their arguments from pyglet in physical coordinates. If you want to map that to virtual coordinates, you need to use the director.get_virtual_coordinates method, which does the correct mapping. If you put instead ``self.posx``, ``self.posy = x,y`` in the on_mouse_press handler above, you will see that the app seems to work, but if you resize the window, the clicks will move the text to the wrong place.

For completneddes, they are other mouse events that can be of interest:
	on_mouse_release : called when a button is released
	on_mouse_scroll : called when the mouse wheel moved
	on_mouse_leave : called when the mouse cursor goes out of the window
	on_mouse_enter : called when the mouse cursor enters the window

The demo does not have much more code, just creating a scene with these two layers and running it::

        director.init(resizable=True)
        # Run a scene with our event displayers:
        director.run( cocos.scene.Scene( KeyDisplay(), MouseDisplay() ) )

You can now play to the demo and change it. Some things you can try are:

 * Change the on_mouse_press handler and remove the mapping to virtual coordinates; note how it behaves strangely after resizing the window
 * Note that the mouse coordinates on screen are physical coordinates, so their range changes when resizing the window; modify the demo to show virtual coordinates.
 * Change the code to be able to move the mouse coordinates label when you drag the mouse
 * Change the code so the keyboard display also shows the modifiers set at each time

Where to next?
--------------

The examples presented in this chapter should have given you enough
information to get started writing simple arcade and point-and-click-based
games.

The remainder of this programming guide goes into quite technical detail
regarding some of cocos's features.  While getting started, it's recommended
that you skim the beginning of each chapter but not attempt to read through
the entire guide from start to finish.

To achieve optimal performance in your 2D
applications you'll need to work with OpenGL directly.  The canonical
references for OpenGL are `The OpenGL Programming Guide`_ and
`The OpenGL Shading Language`_.

Since cocos2d uses pyglet you shall also check `pyglet Programming Guide`_
and `pyglet API Reference`_

There are numerous examples of cocos2d applications in the ``samples/``
directory of the documentation and source distributions.  Keep checking
http://www.cocos2d.org/ for more examples and tutorials as they are written.





.. _The OpenGL Programming Guide: http://opengl.org/documentation/books/#the_opengl_programming_guide_the_official_guide_to_learning_opengl_version
.. _The OpenGL Shading Language: http://opengl.org/documentation/books/#the_opengl_shading_language_2nd_edition
.. _pyglet Programming Guide: http://pyglet.org/doc/programming_guide/
.. _pyglet API Reference: http://pyglet.org/doc/api/
.. _The pyglet Event Framework: http://www.pyglet.org/doc/programming_guide/the_pyglet_event_framework.html
